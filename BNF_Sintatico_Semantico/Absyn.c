/* File generated by the BNF Converter (bnfc 2.9.4). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Program    ********************/

Prog make_Program(Ident p1, Dec p2)
{
    Prog tmp = (Prog) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Program!\n");
        exit(1);
    }
    tmp->kind = is_Program;
    tmp->u.program_.ident_ = p1;
    tmp->u.program_.dec_ = p2;
    return tmp;
}

/********************   Ident    ********************/

Id make_Ident(Ident_type p1)
{
    Id tmp = (Id) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ident!\n");
        exit(1);
    }
    tmp->kind = is_Ident;
    tmp->u.ident_.ident_type_ = p1;
    return tmp;
}

/********************   Idletter    ********************/

Ident_type make_Idletter()
{
    Ident_type tmp = (Ident_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Idletter!\n");
        exit(1);
    }
    tmp->kind = is_Idletter;
    return tmp;
}

/********************   Iddigt    ********************/

Ident_type make_Iddigt()
{
    Ident_type tmp = (Ident_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Iddigt!\n");
        exit(1);
    }
    tmp->kind = is_Iddigt;
    return tmp;
}

/********************   Block    ********************/

Dec make_Block(Label p1, Uses p2, Variable p3, Type p4, Constant p5, Cmdlist p6)
{
    Dec tmp = (Dec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Block!\n");
        exit(1);
    }
    tmp->kind = is_Block;
    tmp->u.block_.label_ = p1;
    tmp->u.block_.uses_ = p2;
    tmp->u.block_.variable_ = p3;
    tmp->u.block_.type_ = p4;
    tmp->u.block_.constant_ = p5;
    tmp->u.block_.cmdlist_ = p6;
    return tmp;
}

/********************   Label    ********************/

Label make_Label(Ident p1)
{
    Label tmp = (Label) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Label!\n");
        exit(1);
    }
    tmp->kind = is_Label;
    tmp->u.label_.ident_ = p1;
    return tmp;
}

/********************   Uses    ********************/

Uses make_Uses(Ident p1, Ident p2)
{
    Uses tmp = (Uses) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Uses!\n");
        exit(1);
    }
    tmp->kind = is_Uses;
    tmp->u.uses_.ident_1 = p1;
    tmp->u.uses_.ident_2 = p2;
    return tmp;
}

/********************   Variable    ********************/

Variable make_Variable(Ident p1, Type p2)
{
    Variable tmp = (Variable) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Variable!\n");
        exit(1);
    }
    tmp->kind = is_Variable;
    tmp->u.variable_.ident_ = p1;
    tmp->u.variable_.type_ = p2;
    return tmp;
}

/********************   Type    ********************/

Type make_Type(Type_specifier p1)
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type!\n");
        exit(1);
    }
    tmp->kind = is_Type;
    tmp->u.type_.type_specifier_ = p1;
    return tmp;
}

/********************   Tint    ********************/

Type_specifier make_Tint()
{
    Type_specifier tmp = (Type_specifier) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Tint!\n");
        exit(1);
    }
    tmp->kind = is_Tint;
    return tmp;
}

/********************   Tfloat    ********************/

Type_specifier make_Tfloat()
{
    Type_specifier tmp = (Type_specifier) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Tfloat!\n");
        exit(1);
    }
    tmp->kind = is_Tfloat;
    return tmp;
}

/********************   Tdouble    ********************/

Type_specifier make_Tdouble()
{
    Type_specifier tmp = (Type_specifier) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Tdouble!\n");
        exit(1);
    }
    tmp->kind = is_Tdouble;
    return tmp;
}

/********************   Constant    ********************/

Constant make_Constant()
{
    Constant tmp = (Constant) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Constant!\n");
        exit(1);
    }
    tmp->kind = is_Constant;
    return tmp;
}

/********************   Cmdlist    ********************/

Cmdlist make_Cmdlist(Cmd p1, Cmd p2)
{
    Cmdlist tmp = (Cmdlist) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmdlist!\n");
        exit(1);
    }
    tmp->kind = is_Cmdlist;
    tmp->u.cmdlist_.cmd_1 = p1;
    tmp->u.cmdlist_.cmd_2 = p2;
    return tmp;
}

/********************   Cmd    ********************/

Cmd make_Cmd(Cmd_type p1)
{
    Cmd tmp = (Cmd) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd!\n");
        exit(1);
    }
    tmp->kind = is_Cmd;
    tmp->u.cmd_.cmd_type_ = p1;
    return tmp;
}

/********************   Cmd_goto    ********************/

Cmd_type make_Cmd_goto(Label p1)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_goto!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_goto;
    tmp->u.cmd_goto_.label_ = p1;
    return tmp;
}

/********************   Cmd_assign    ********************/

Cmd_type make_Cmd_assign(Variable p1, Exprecion p2)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_assign!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_assign;
    tmp->u.cmd_assign_.variable_ = p1;
    tmp->u.cmd_assign_.exprecion_ = p2;
    return tmp;
}

/********************   Cmd_while    ********************/

Cmd_type make_Cmd_while(Exprecion p1, Cmdlist p2)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_while!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_while;
    tmp->u.cmd_while_.exprecion_ = p1;
    tmp->u.cmd_while_.cmdlist_ = p2;
    return tmp;
}

/********************   Cmd_for    ********************/

Cmd_type make_Cmd_for(Exprecion p1, Cmdlist p2)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_for!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_for;
    tmp->u.cmd_for_.exprecion_ = p1;
    tmp->u.cmd_for_.cmdlist_ = p2;
    return tmp;
}

/********************   Cmd_if    ********************/

Cmd_type make_Cmd_if(Exprecion p1, Cmdlist p2, Cmdlist p3)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_if!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_if;
    tmp->u.cmd_if_.exprecion_ = p1;
    tmp->u.cmd_if_.cmdlist_1 = p2;
    tmp->u.cmd_if_.cmdlist_2 = p3;
    return tmp;
}

/********************   Cmd_output    ********************/

Cmd_type make_Cmd_output(Exprecion p1)
{
    Cmd_type tmp = (Cmd_type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd_output!\n");
        exit(1);
    }
    tmp->kind = is_Cmd_output;
    tmp->u.cmd_output_.exprecion_ = p1;
    return tmp;
}

/********************   Exprecion    ********************/

Exprecion make_Exprecion(Exp p1)
{
    Exprecion tmp = (Exprecion) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Exprecion!\n");
        exit(1);
    }
    tmp->kind = is_Exprecion;
    tmp->u.exprecion_.exp_ = p1;
    return tmp;
}

/********************   Expeq    ********************/

Exp make_Expeq(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expeq!\n");
        exit(1);
    }
    tmp->kind = is_Expeq;
    tmp->u.expeq_.exp_1 = p1;
    tmp->u.expeq_.exp_2 = p2;
    return tmp;
}

/********************   Expenq    ********************/

Exp make_Expenq(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expenq!\n");
        exit(1);
    }
    tmp->kind = is_Expenq;
    tmp->u.expenq_.exp_1 = p1;
    tmp->u.expenq_.exp_2 = p2;
    return tmp;
}

/********************   Expmaior    ********************/

Exp make_Expmaior(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expmaior!\n");
        exit(1);
    }
    tmp->kind = is_Expmaior;
    tmp->u.expmaior_.exp_1 = p1;
    tmp->u.expmaior_.exp_2 = p2;
    return tmp;
}

/********************   Expmenor    ********************/

Exp make_Expmenor(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expmenor!\n");
        exit(1);
    }
    tmp->kind = is_Expmenor;
    tmp->u.expmenor_.exp_1 = p1;
    tmp->u.expmenor_.exp_2 = p2;
    return tmp;
}

/********************   Expmaioreq    ********************/

Exp make_Expmaioreq(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expmaioreq!\n");
        exit(1);
    }
    tmp->kind = is_Expmaioreq;
    tmp->u.expmaioreq_.exp_1 = p1;
    tmp->u.expmaioreq_.exp_2 = p2;
    return tmp;
}

/********************   Expmenoreq    ********************/

Exp make_Expmenoreq(Exp p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expmenoreq!\n");
        exit(1);
    }
    tmp->kind = is_Expmenoreq;
    tmp->u.expmenoreq_.exp_1 = p1;
    tmp->u.expmenoreq_.exp_2 = p2;
    return tmp;
}

/********************   Funtion    ********************/

Procedure make_Funtion(Ident p1, Variable p2, Cmdlist p3)
{
    Procedure tmp = (Procedure) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Funtion!\n");
        exit(1);
    }
    tmp->kind = is_Funtion;
    tmp->u.funtion_.ident_ = p1;
    tmp->u.funtion_.variable_ = p2;
    tmp->u.funtion_.cmdlist_ = p3;
    return tmp;
}

/***************************   Cloning   ******************************/

Prog clone_Prog(Prog p)
{
  switch(p->kind)
  {
  case is_Program:
    return make_Program
      ( strdup(p->u.program_.ident_)
      , clone_Dec(p->u.program_.dec_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prog!\n");
    exit(1);
  }
}

Id clone_Id(Id p)
{
  switch(p->kind)
  {
  case is_Ident:
    return make_Ident (clone_Ident_type(p->u.ident_.ident_type_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Id!\n");
    exit(1);
  }
}

Ident_type clone_Ident_type(Ident_type p)
{
  switch(p->kind)
  {
  case is_Idletter:
    return make_Idletter ();

  case is_Iddigt:
    return make_Iddigt ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Ident_type!\n");
    exit(1);
  }
}

Dec clone_Dec(Dec p)
{
  switch(p->kind)
  {
  case is_Block:
    return make_Block
      ( clone_Label(p->u.block_.label_)
      , clone_Uses(p->u.block_.uses_)
      , clone_Variable(p->u.block_.variable_)
      , clone_Type(p->u.block_.type_)
      , clone_Constant(p->u.block_.constant_)
      , clone_Cmdlist(p->u.block_.cmdlist_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Dec!\n");
    exit(1);
  }
}

Label clone_Label(Label p)
{
  switch(p->kind)
  {
  case is_Label:
    return make_Label (strdup(p->u.label_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Label!\n");
    exit(1);
  }
}

Uses clone_Uses(Uses p)
{
  switch(p->kind)
  {
  case is_Uses:
    return make_Uses
      ( strdup(p->u.uses_.ident_1)
      , strdup(p->u.uses_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Uses!\n");
    exit(1);
  }
}

Variable clone_Variable(Variable p)
{
  switch(p->kind)
  {
  case is_Variable:
    return make_Variable
      ( strdup(p->u.variable_.ident_)
      , clone_Type(p->u.variable_.type_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Variable!\n");
    exit(1);
  }
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type:
    return make_Type (clone_Type_specifier(p->u.type_.type_specifier_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

Type_specifier clone_Type_specifier(Type_specifier p)
{
  switch(p->kind)
  {
  case is_Tint:
    return make_Tint ();

  case is_Tfloat:
    return make_Tfloat ();

  case is_Tdouble:
    return make_Tdouble ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type_specifier!\n");
    exit(1);
  }
}

Constant clone_Constant(Constant p)
{
  switch(p->kind)
  {
  case is_Constant:
    return make_Constant ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Constant!\n");
    exit(1);
  }
}

Cmdlist clone_Cmdlist(Cmdlist p)
{
  switch(p->kind)
  {
  case is_Cmdlist:
    return make_Cmdlist
      ( clone_Cmd(p->u.cmdlist_.cmd_1)
      , clone_Cmd(p->u.cmdlist_.cmd_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Cmdlist!\n");
    exit(1);
  }
}

Cmd clone_Cmd(Cmd p)
{
  switch(p->kind)
  {
  case is_Cmd:
    return make_Cmd (clone_Cmd_type(p->u.cmd_.cmd_type_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Cmd!\n");
    exit(1);
  }
}

Cmd_type clone_Cmd_type(Cmd_type p)
{
  switch(p->kind)
  {
  case is_Cmd_goto:
    return make_Cmd_goto (clone_Label(p->u.cmd_goto_.label_));

  case is_Cmd_assign:
    return make_Cmd_assign
      ( clone_Variable(p->u.cmd_assign_.variable_)
      , clone_Exprecion(p->u.cmd_assign_.exprecion_)
      );

  case is_Cmd_while:
    return make_Cmd_while
      ( clone_Exprecion(p->u.cmd_while_.exprecion_)
      , clone_Cmdlist(p->u.cmd_while_.cmdlist_)
      );

  case is_Cmd_for:
    return make_Cmd_for
      ( clone_Exprecion(p->u.cmd_for_.exprecion_)
      , clone_Cmdlist(p->u.cmd_for_.cmdlist_)
      );

  case is_Cmd_if:
    return make_Cmd_if
      ( clone_Exprecion(p->u.cmd_if_.exprecion_)
      , clone_Cmdlist(p->u.cmd_if_.cmdlist_1)
      , clone_Cmdlist(p->u.cmd_if_.cmdlist_2)
      );

  case is_Cmd_output:
    return make_Cmd_output (clone_Exprecion(p->u.cmd_output_.exprecion_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Cmd_type!\n");
    exit(1);
  }
}

Exprecion clone_Exprecion(Exprecion p)
{
  switch(p->kind)
  {
  case is_Exprecion:
    return make_Exprecion (clone_Exp(p->u.exprecion_.exp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Exprecion!\n");
    exit(1);
  }
}

Exp clone_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_Expeq:
    return make_Expeq
      ( clone_Exp(p->u.expeq_.exp_1)
      , clone_Exp(p->u.expeq_.exp_2)
      );

  case is_Expenq:
    return make_Expenq
      ( clone_Exp(p->u.expenq_.exp_1)
      , clone_Exp(p->u.expenq_.exp_2)
      );

  case is_Expmaior:
    return make_Expmaior
      ( clone_Exp(p->u.expmaior_.exp_1)
      , clone_Exp(p->u.expmaior_.exp_2)
      );

  case is_Expmenor:
    return make_Expmenor
      ( clone_Exp(p->u.expmenor_.exp_1)
      , clone_Exp(p->u.expmenor_.exp_2)
      );

  case is_Expmaioreq:
    return make_Expmaioreq
      ( clone_Exp(p->u.expmaioreq_.exp_1)
      , clone_Exp(p->u.expmaioreq_.exp_2)
      );

  case is_Expmenoreq:
    return make_Expmenoreq
      ( clone_Exp(p->u.expmenoreq_.exp_1)
      , clone_Exp(p->u.expmenoreq_.exp_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Exp!\n");
    exit(1);
  }
}

Procedure clone_Procedure(Procedure p)
{
  switch(p->kind)
  {
  case is_Funtion:
    return make_Funtion
      ( strdup(p->u.funtion_.ident_)
      , clone_Variable(p->u.funtion_.variable_)
      , clone_Cmdlist(p->u.funtion_.cmdlist_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Procedure!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prog(Prog p)
{
  switch(p->kind)
  {
  case is_Program:
    free(p->u.program_.ident_);
    free_Dec(p->u.program_.dec_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prog!\n");
    exit(1);
  }
  free(p);
}

void free_Id(Id p)
{
  switch(p->kind)
  {
  case is_Ident:
    free_Ident_type(p->u.ident_.ident_type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Id!\n");
    exit(1);
  }
  free(p);
}

void free_Ident_type(Ident_type p)
{
  switch(p->kind)
  {
  case is_Idletter:
    break;

  case is_Iddigt:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Ident_type!\n");
    exit(1);
  }
  free(p);
}

void free_Dec(Dec p)
{
  switch(p->kind)
  {
  case is_Block:
    free_Label(p->u.block_.label_);
    free_Uses(p->u.block_.uses_);
    free_Variable(p->u.block_.variable_);
    free_Type(p->u.block_.type_);
    free_Constant(p->u.block_.constant_);
    free_Cmdlist(p->u.block_.cmdlist_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Dec!\n");
    exit(1);
  }
  free(p);
}

void free_Label(Label p)
{
  switch(p->kind)
  {
  case is_Label:
    free(p->u.label_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Label!\n");
    exit(1);
  }
  free(p);
}

void free_Uses(Uses p)
{
  switch(p->kind)
  {
  case is_Uses:
    free(p->u.uses_.ident_1);
    free(p->u.uses_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Uses!\n");
    exit(1);
  }
  free(p);
}

void free_Variable(Variable p)
{
  switch(p->kind)
  {
  case is_Variable:
    free(p->u.variable_.ident_);
    free_Type(p->u.variable_.type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Variable!\n");
    exit(1);
  }
  free(p);
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type:
    free_Type_specifier(p->u.type_.type_specifier_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_Type_specifier(Type_specifier p)
{
  switch(p->kind)
  {
  case is_Tint:
    break;

  case is_Tfloat:
    break;

  case is_Tdouble:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type_specifier!\n");
    exit(1);
  }
  free(p);
}

void free_Constant(Constant p)
{
  switch(p->kind)
  {
  case is_Constant:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Constant!\n");
    exit(1);
  }
  free(p);
}

void free_Cmdlist(Cmdlist p)
{
  switch(p->kind)
  {
  case is_Cmdlist:
    free_Cmd(p->u.cmdlist_.cmd_1);
    free_Cmd(p->u.cmdlist_.cmd_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Cmdlist!\n");
    exit(1);
  }
  free(p);
}

void free_Cmd(Cmd p)
{
  switch(p->kind)
  {
  case is_Cmd:
    free_Cmd_type(p->u.cmd_.cmd_type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Cmd!\n");
    exit(1);
  }
  free(p);
}

void free_Cmd_type(Cmd_type p)
{
  switch(p->kind)
  {
  case is_Cmd_goto:
    free_Label(p->u.cmd_goto_.label_);
    break;

  case is_Cmd_assign:
    free_Variable(p->u.cmd_assign_.variable_);
    free_Exprecion(p->u.cmd_assign_.exprecion_);
    break;

  case is_Cmd_while:
    free_Exprecion(p->u.cmd_while_.exprecion_);
    free_Cmdlist(p->u.cmd_while_.cmdlist_);
    break;

  case is_Cmd_for:
    free_Exprecion(p->u.cmd_for_.exprecion_);
    free_Cmdlist(p->u.cmd_for_.cmdlist_);
    break;

  case is_Cmd_if:
    free_Exprecion(p->u.cmd_if_.exprecion_);
    free_Cmdlist(p->u.cmd_if_.cmdlist_1);
    free_Cmdlist(p->u.cmd_if_.cmdlist_2);
    break;

  case is_Cmd_output:
    free_Exprecion(p->u.cmd_output_.exprecion_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Cmd_type!\n");
    exit(1);
  }
  free(p);
}

void free_Exprecion(Exprecion p)
{
  switch(p->kind)
  {
  case is_Exprecion:
    free_Exp(p->u.exprecion_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Exprecion!\n");
    exit(1);
  }
  free(p);
}

void free_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_Expeq:
    free_Exp(p->u.expeq_.exp_1);
    free_Exp(p->u.expeq_.exp_2);
    break;

  case is_Expenq:
    free_Exp(p->u.expenq_.exp_1);
    free_Exp(p->u.expenq_.exp_2);
    break;

  case is_Expmaior:
    free_Exp(p->u.expmaior_.exp_1);
    free_Exp(p->u.expmaior_.exp_2);
    break;

  case is_Expmenor:
    free_Exp(p->u.expmenor_.exp_1);
    free_Exp(p->u.expmenor_.exp_2);
    break;

  case is_Expmaioreq:
    free_Exp(p->u.expmaioreq_.exp_1);
    free_Exp(p->u.expmaioreq_.exp_2);
    break;

  case is_Expmenoreq:
    free_Exp(p->u.expmenoreq_.exp_1);
    free_Exp(p->u.expmenoreq_.exp_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Exp!\n");
    exit(1);
  }
  free(p);
}

void free_Procedure(Procedure p)
{
  switch(p->kind)
  {
  case is_Funtion:
    free(p->u.funtion_.ident_);
    free_Variable(p->u.funtion_.variable_);
    free_Cmdlist(p->u.funtion_.cmdlist_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Procedure!\n");
    exit(1);
  }
  free(p);
}

