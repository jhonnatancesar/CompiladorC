/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the jair_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE jair__scan_string(const char *str, yyscan_t scanner);
extern void jair__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void jair_lex_destroy(yyscan_t scanner);
extern char* jair_get_text(yyscan_t scanner);

extern yyscan_t jair__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Prog prog_;
  Id id_;
  Ident_type ident_type_;
  Dec dec_;
  Label label_;
  Uses uses_;
  Variable variable_;
  Type type_;
  Type_specifier type_specifier_;
  Constant constant_;
  Cmdlist cmdlist_;
  Cmd cmd_;
  Cmd_type cmd_type_;
  Exprecion exprecion_;
  Exp exp_;
  Procedure procedure_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, jair_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN        /* ( */
%token          _RPAREN        /* ) */
%token          _COMMA         /* , */
%token          _SEMI          /* ; */
%token          _LT            /* < */
%token          _LDARROW       /* <= */
%token          _LTGT          /* <> */
%token          _EQ            /* = */
%token          _DEQ           /* == */
%token          _GT            /* > */
%token          _GTEQ          /* >= */
%token          _KW_Output     /* Output */
%token          _KW_Procedure  /* Procedure */
%token          _LBRACK        /* [ */
%token          _RBRACK        /* ] */
%token          _KW_assign     /* assign */
%token          _KW_begin      /* begin */
%token          _KW_digit      /* digit */
%token          _KW_do         /* do */
%token          _KW_double     /* double */
%token          _KW_else       /* else */
%token          _SYMB_1        /* end. */
%token          _KW_float      /* float */
%token          _KW_for        /* for */
%token          _KW_goto       /* goto */
%token          _KW_if         /* if */
%token          _KW_int        /* int */
%token          _KW_letter     /* letter */
%token          _KW_number     /* number */
%token          _KW_program    /* program */
%token          _KW_then       /* then */
%token          _KW_while      /* while */
%token          _LBRACE        /* { */
%token          _RBRACE        /* } */
%token          _SYMB_6        /* }; */
%token<_string> _IDENT_

%type <prog_> Prog
%type <id_> Id
%type <ident_type_> Ident_type
%type <dec_> Dec
%type <label_> Label
%type <uses_> Uses
%type <variable_> Variable
%type <type_> Type
%type <type_specifier_> Type_specifier
%type <constant_> Constant
%type <cmdlist_> Cmdlist
%type <cmd_> Cmd
%type <cmd_type_> Cmd_type
%type <exprecion_> Exprecion
%type <exp_> Exp
%type <exp_> Exp2
%type <procedure_> Procedure

%start Prog

%%

Prog : _KW_program _IDENT_ _SEMI Dec { $$ = make_Program($2, $4); result->prog_ = $$; }
;
Id : Ident_type { $$ = make_Ident($1); result->id_ = $$; }
;
Ident_type : _KW_letter { $$ = make_Idletter(); result->ident_type_ = $$; }
  | _KW_digit { $$ = make_Iddigt(); result->ident_type_ = $$; }
;
Dec : Label Uses Variable Type Constant _KW_begin Cmdlist _SYMB_1 { $$ = make_Block($1, $2, $3, $4, $5, $7); result->dec_ = $$; }
;
Label : _IDENT_ { $$ = make_Label($1); result->label_ = $$; }
;
Uses : _IDENT_ _LBRACE _COMMA _IDENT_ _RBRACE _SEMI { $$ = make_Uses($1, $4); result->uses_ = $$; }
;
Variable : _IDENT_ _EQ Type _SEMI { $$ = make_Variable($1, $3); result->variable_ = $$; }
;
Type : Type_specifier { $$ = make_Type($1); result->type_ = $$; }
;
Type_specifier : _KW_int { $$ = make_Tint(); result->type_specifier_ = $$; }
  | _KW_float { $$ = make_Tfloat(); result->type_specifier_ = $$; }
  | _KW_double { $$ = make_Tdouble(); result->type_specifier_ = $$; }
;
Constant : _KW_number _SEMI { $$ = make_Constant(); result->constant_ = $$; }
;
Cmdlist : Cmd _LBRACE Cmd _SYMB_6 { $$ = make_Cmdlist($1, $3); result->cmdlist_ = $$; }
;
Cmd : Cmd_type { $$ = make_Cmd($1); result->cmd_ = $$; }
;
Cmd_type : _KW_goto Label { $$ = make_Cmd_goto($2); result->cmd_type_ = $$; }
  | _KW_assign Variable _EQ Exprecion { $$ = make_Cmd_assign($2, $4); result->cmd_type_ = $$; }
  | _KW_while Exprecion _KW_do Cmdlist { $$ = make_Cmd_while($2, $4); result->cmd_type_ = $$; }
  | _KW_for Exprecion Cmdlist { $$ = make_Cmd_for($2, $3); result->cmd_type_ = $$; }
  | _KW_if Exprecion _KW_then Cmdlist _LBRACK _KW_else Cmdlist _RBRACK { $$ = make_Cmd_if($2, $4, $7); result->cmd_type_ = $$; }
  | _KW_Output Exprecion { $$ = make_Cmd_output($2); result->cmd_type_ = $$; }
;
Exprecion : Exp { $$ = make_Exprecion($1); result->exprecion_ = $$; }
;
Exp : Exp _DEQ Exp2 { $$ = make_Expeq($1, $3); result->exp_ = $$; }
  | Exp _LTGT Exp2 { $$ = make_Expenq($1, $3); result->exp_ = $$; }
;
Exp2 : Exp2 _GT Exp2 { $$ = make_Expmaior($1, $3); result->exp_ = $$; }
  | Exp2 _LT Exp2 { $$ = make_Expmenor($1, $3); result->exp_ = $$; }
  | Exp2 _GTEQ Exp2 { $$ = make_Expmaioreq($1, $3); result->exp_ = $$; }
  | Exp2 _LDARROW Exp2 { $$ = make_Expmenoreq($1, $3); result->exp_ = $$; }
;
Procedure : _KW_Procedure _IDENT_ _LPAREN Variable _RPAREN _KW_begin Cmdlist _SYMB_1 { $$ = make_Funtion($2, $4, $7); result->procedure_ = $$; }
;

%%


/* Entrypoint: parse Prog from file. */
Prog pProg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prog_;
  }
}

/* Entrypoint: parse Prog from string. */
Prog psProg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prog_;
  }
}

/* Entrypoint: parse Id from file. */
Id pId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.id_;
  }
}

/* Entrypoint: parse Id from string. */
Id psId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.id_;
  }
}

/* Entrypoint: parse Ident_type from file. */
Ident_type pIdent_type(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ident_type_;
  }
}

/* Entrypoint: parse Ident_type from string. */
Ident_type psIdent_type(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ident_type_;
  }
}

/* Entrypoint: parse Dec from file. */
Dec pDec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dec_;
  }
}

/* Entrypoint: parse Dec from string. */
Dec psDec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dec_;
  }
}

/* Entrypoint: parse Label from file. */
Label pLabel(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse Label from string. */
Label psLabel(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse Uses from file. */
Uses pUses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uses_;
  }
}

/* Entrypoint: parse Uses from string. */
Uses psUses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uses_;
  }
}

/* Entrypoint: parse Variable from file. */
Variable pVariable(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variable_;
  }
}

/* Entrypoint: parse Variable from string. */
Variable psVariable(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variable_;
  }
}

/* Entrypoint: parse Type from file. */
Type pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type from string. */
Type psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type_specifier from file. */
Type_specifier pType_specifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_specifier_;
  }
}

/* Entrypoint: parse Type_specifier from string. */
Type_specifier psType_specifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_specifier_;
  }
}

/* Entrypoint: parse Constant from file. */
Constant pConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Constant from string. */
Constant psConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Cmdlist from file. */
Cmdlist pCmdlist(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmdlist_;
  }
}

/* Entrypoint: parse Cmdlist from string. */
Cmdlist psCmdlist(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmdlist_;
  }
}

/* Entrypoint: parse Cmd from file. */
Cmd pCmd(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse Cmd from string. */
Cmd psCmd(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse Cmd_type from file. */
Cmd_type pCmd_type(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_type_;
  }
}

/* Entrypoint: parse Cmd_type from string. */
Cmd_type psCmd_type(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_type_;
  }
}

/* Entrypoint: parse Exprecion from file. */
Exprecion pExprecion(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exprecion_;
  }
}

/* Entrypoint: parse Exprecion from string. */
Exprecion psExprecion(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exprecion_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Procedure from file. */
Procedure pProcedure(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedure_;
  }
}

/* Entrypoint: parse Procedure from string. */
Procedure psProcedure(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedure_;
  }
}



