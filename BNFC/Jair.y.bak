/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the jair_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE jair__scan_string(const char *str, yyscan_t scanner);
extern void jair__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void jair_lex_destroy(yyscan_t scanner);
extern char* jair_get_text(yyscan_t scanner);

extern yyscan_t jair__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Prog prog_;
  Id id_;
  Ident_type ident_type_;
  Dec dec_;
  Label label_;
  Uses uses_;
  Variable variable_;
  Type type_;
  Type_specifier type_specifier_;
  Constant constant_;
  Cmdlist cmdlist_;
  Cmd cmd_;
  Cmd_type cmd_type_;
  Exp exp_;
  Procedure procedure_;
  Assignment_op assignment_op_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, jair_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ          /* != */
%token          _PERCENT         /* % */
%token          _PERCENTEQ       /* %= */
%token          _AMP             /* & */
%token          _DAMP            /* && */
%token          _AMPEQ           /* &= */
%token          _LPAREN          /* ( */
%token          _RPAREN          /* ) */
%token          _STAR            /* * */
%token          _STAREQ          /* *= */
%token          _PLUS            /* + */
%token          _DPLUS           /* ++ */
%token          _PLUSEQ          /* += */
%token          _COMMA           /* , */
%token          _MINUS           /* - */
%token          _DMINUS          /* -- */
%token          _MINUSEQ         /* -= */
%token          _RARROW          /* -> */
%token          _DOT             /* . */
%token          _SLASH           /* / */
%token          _SLASHEQ         /* /= */
%token          _COLON           /* : */
%token          _SEMI            /* ; */
%token          _LT              /* < */
%token          _DLT             /* << */
%token          _DLTEQ           /* <<= */
%token          _LDARROW         /* <= */
%token          _EQ              /* = */
%token          _DEQ             /* == */
%token          _GT              /* > */
%token          _GTEQ            /* >= */
%token          _DGT             /* >> */
%token          _DGTEQ           /* >>= */
%token          _QUESTION        /* ? */
%token          _KW_Procedure    /* Procedure */
%token          _KW_Write        /* Write */
%token          _LBRACK          /* [ */
%token          _RBRACK          /* ] */
%token          _CARET           /* ^ */
%token          _CARETEQ         /* ^= */
%token          _KW_assign       /* assign */
%token          _KW_begin        /* begin */
%token          _KW_digit        /* digit */
%token          _KW_do           /* do */
%token          _KW_double       /* double */
%token          _KW_else         /* else */
%token          _SYMB_1          /* end. */
%token          _KW_float        /* float */
%token          _KW_for          /* for */
%token          _KW_goto         /* goto */
%token          _KW_if           /* if */
%token          _KW_int          /* int */
%token          _KW_letter       /* letter */
%token          _KW_number       /* number */
%token          _KW_program      /* program */
%token          _KW_then         /* then */
%token          _KW_while        /* while */
%token          _LBRACE          /* { */
%token          _BAR             /* | */
%token          _BAREQ           /* |= */
%token          _DBAR            /* || */
%token          _RBRACE          /* } */
%token          _SYMB_6          /* }; */
%token<_string> T_CDouble        /* CDouble */
%token<_string> T_CFloat         /* CFloat */
%token<_string> T_CLongDouble    /* CLongDouble */
%token<_string> T_HexLong        /* HexLong */
%token<_string> T_HexUnsLong     /* HexUnsLong */
%token<_string> T_HexUnsigned    /* HexUnsigned */
%token<_string> T_Hexadecimal    /* Hexadecimal */
%token<_string> T_Long           /* Long */
%token<_string> T_Octal          /* Octal */
%token<_string> T_OctalLong      /* OctalLong */
%token<_string> T_OctalUnsLong   /* OctalUnsLong */
%token<_string> T_OctalUnsigned  /* OctalUnsigned */
%token<_string> T_Unsigned       /* Unsigned */
%token<_string> T_UnsignedLong   /* UnsignedLong */
%token<_string> _STRING_
%token<_string> _IDENT_

%type <prog_> Prog
%type <id_> Id
%type <ident_type_> Ident_type
%type <dec_> Dec
%type <label_> Label
%type <uses_> Uses
%type <variable_> Variable
%type <type_> Type
%type <type_specifier_> Type_specifier
%type <constant_> Constant
%type <cmdlist_> Cmdlist
%type <cmd_> Cmd
%type <cmd_type_> Cmd_type
%type <exp_> Exp
%type <exp_> Exp2
%type <exp_> Exp3
%type <exp_> Exp4
%type <exp_> Exp5
%type <exp_> Exp6
%type <exp_> Exp7
%type <exp_> Exp8
%type <exp_> Exp9
%type <exp_> Exp10
%type <exp_> Exp11
%type <exp_> Exp12
%type <exp_> Exp13
%type <exp_> Exp14
%type <exp_> Exp15
%type <exp_> Exp16
%type <procedure_> Procedure
%type <assignment_op_> Assignment_op

%start Prog

%%

Prog : _KW_program _IDENT_ _SEMI Dec { $$ = make_Program($2, $4); result->prog_ = $$; }
;
Id : Ident_type { $$ = make_Ident($1); result->id_ = $$; }
;
Ident_type : _KW_letter { $$ = make_Idletter(); result->ident_type_ = $$; }
  | _KW_digit { $$ = make_Iddigt(); result->ident_type_ = $$; }
;
Dec : Label Uses Variable Type Constant _KW_begin Cmdlist _SYMB_1 { $$ = make_Block($1, $2, $3, $4, $5, $7); result->dec_ = $$; }
;
Label : _IDENT_ { $$ = make_Label($1); result->label_ = $$; }
;
Uses : _IDENT_ _LBRACE _COMMA _IDENT_ _RBRACE _SEMI { $$ = make_Uses($1, $4); result->uses_ = $$; }
;
Variable : _IDENT_ _COLON Type _SEMI { $$ = make_Variable($1, $3); result->variable_ = $$; }
;
Type : Type_specifier { $$ = make_Type($1); result->type_ = $$; }
;
Type_specifier : _KW_int { $$ = make_Tint(); result->type_specifier_ = $$; }
  | _KW_float { $$ = make_Tfloat(); result->type_specifier_ = $$; }
  | _KW_double { $$ = make_Tdouble(); result->type_specifier_ = $$; }
;
Constant : _KW_number _SEMI { $$ = make_Constant(); result->constant_ = $$; }
;
Cmdlist : Cmd _LBRACE Cmd _SYMB_6 { $$ = make_Cmdlist($1, $3); result->cmdlist_ = $$; }
;
Cmd : Cmd_type { $$ = make_Cmd($1); result->cmd_ = $$; }
;
Cmd_type : _KW_goto Label { $$ = make_Cmd_goto($2); result->cmd_type_ = $$; }
  | _KW_assign Variable _EQ Exp { $$ = make_Cmd_assign($2, $4); result->cmd_type_ = $$; }
  | _KW_while Exp _KW_do Cmdlist { $$ = make_Cmd_while($2, $4); result->cmd_type_ = $$; }
  | _KW_for Exp Cmdlist { $$ = make_Cmd_for($2, $3); result->cmd_type_ = $$; }
  | _KW_if Exp _KW_then Cmdlist _LBRACK _KW_else Cmdlist _RBRACK { $$ = make_Cmd_if($2, $4, $7); result->cmd_type_ = $$; }
  | _KW_Write Exp { $$ = make_Cmd_output($2); result->cmd_type_ = $$; }
;
Exp : Exp _COMMA Exp2 { $$ = make_Ecomma($1, $3); result->exp_ = $$; }
;
Exp2 : Exp14 Assignment_op Exp2 { $$ = make_Eassign($1, $2, $3); result->exp_ = $$; }
;
Exp3 : Exp4 _QUESTION Exp _COLON Exp3 { $$ = make_Econdition($1, $3, $5); result->exp_ = $$; }
;
Exp4 : Exp4 _DBAR Exp5 { $$ = make_Elor($1, $3); result->exp_ = $$; }
;
Exp5 : Exp5 _DAMP Exp6 { $$ = make_Eland($1, $3); result->exp_ = $$; }
;
Exp6 : Exp6 _BAR Exp7 { $$ = make_Ebitor($1, $3); result->exp_ = $$; }
;
Exp7 : Exp7 _CARET Exp8 { $$ = make_Ebitexor($1, $3); result->exp_ = $$; }
;
Exp8 : Exp8 _AMP Exp9 { $$ = make_Ebitand($1, $3); result->exp_ = $$; }
;
Exp9 : Exp9 _DEQ Exp10 { $$ = make_Eeq($1, $3); result->exp_ = $$; }
  | Exp9 _BANGEQ Exp10 { $$ = make_Eneq($1, $3); result->exp_ = $$; }
;
Exp10 : Exp10 _LT Exp11 { $$ = make_Elthen($1, $3); result->exp_ = $$; }
  | Exp10 _GT Exp11 { $$ = make_Egrthen($1, $3); result->exp_ = $$; }
  | Exp10 _LDARROW Exp11 { $$ = make_Ele($1, $3); result->exp_ = $$; }
  | Exp10 _GTEQ Exp11 { $$ = make_Ege($1, $3); result->exp_ = $$; }
;
Exp11 : Exp11 _DLT Exp12 { $$ = make_Eleft($1, $3); result->exp_ = $$; }
  | Exp11 _DGT Exp12 { $$ = make_Eright($1, $3); result->exp_ = $$; }
;
Exp12 : Exp12 _PLUS Exp13 { $$ = make_Eplus($1, $3); result->exp_ = $$; }
  | Exp12 _MINUS Exp13 { $$ = make_Eminus($1, $3); result->exp_ = $$; }
;
Exp13 : Exp13 _STAR Exp14 { $$ = make_Etimes($1, $3); result->exp_ = $$; }
  | Exp13 _SLASH Exp14 { $$ = make_Ediv($1, $3); result->exp_ = $$; }
  | Exp13 _PERCENT Exp14 { $$ = make_Emod($1, $3); result->exp_ = $$; }
;
Exp14 : _DPLUS Exp14 { $$ = make_Epreinc($2); result->exp_ = $$; }
  | _DMINUS Exp14 { $$ = make_Epredec($2); result->exp_ = $$; }
;
Exp15 : Exp15 _LBRACK Exp _RBRACK { $$ = make_Earray($1, $3); result->exp_ = $$; }
  | Exp15 _LPAREN _RPAREN { $$ = make_Efunk($1); result->exp_ = $$; }
  | Exp15 _LPAREN Exp2 _RPAREN { $$ = make_Efunkpar($1, $3); result->exp_ = $$; }
  | Exp15 _DOT _IDENT_ { $$ = make_Eselect($1, $3); result->exp_ = $$; }
  | Exp15 _RARROW _IDENT_ { $$ = make_Epoint($1, $3); result->exp_ = $$; }
  | Exp15 _DPLUS { $$ = make_Epostinc($1); result->exp_ = $$; }
  | Exp15 _DMINUS { $$ = make_Epostdec($1); result->exp_ = $$; }
;
Exp16 : _IDENT_ { $$ = make_Evar($1); result->exp_ = $$; }
  | Constant { $$ = make_Econst($1); result->exp_ = $$; }
  | _STRING_ { $$ = make_Estring($1); result->exp_ = $$; }
;
Procedure : _KW_Procedure _IDENT_ _LPAREN Variable _RPAREN _KW_begin Cmdlist _SYMB_1 { $$ = make_Funtion($2, $4, $7); result->procedure_ = $$; }
;
Assignment_op : _EQ { $$ = make_Assign(); result->assignment_op_ = $$; }
  | _STAREQ { $$ = make_AssignMul(); result->assignment_op_ = $$; }
  | _SLASHEQ { $$ = make_AssignDiv(); result->assignment_op_ = $$; }
  | _PERCENTEQ { $$ = make_AssignMod(); result->assignment_op_ = $$; }
  | _PLUSEQ { $$ = make_AssignAdd(); result->assignment_op_ = $$; }
  | _MINUSEQ { $$ = make_AssignSub(); result->assignment_op_ = $$; }
  | _DLTEQ { $$ = make_AssignLeft(); result->assignment_op_ = $$; }
  | _DGTEQ { $$ = make_AssignRight(); result->assignment_op_ = $$; }
  | _AMPEQ { $$ = make_AssignAnd(); result->assignment_op_ = $$; }
  | _CARETEQ { $$ = make_AssignXor(); result->assignment_op_ = $$; }
  | _BAREQ { $$ = make_AssignOr(); result->assignment_op_ = $$; }
;

%%


/* Entrypoint: parse Prog from file. */
Prog pProg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prog_;
  }
}

/* Entrypoint: parse Prog from string. */
Prog psProg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prog_;
  }
}

/* Entrypoint: parse Id from file. */
Id pId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.id_;
  }
}

/* Entrypoint: parse Id from string. */
Id psId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.id_;
  }
}

/* Entrypoint: parse Ident_type from file. */
Ident_type pIdent_type(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ident_type_;
  }
}

/* Entrypoint: parse Ident_type from string. */
Ident_type psIdent_type(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ident_type_;
  }
}

/* Entrypoint: parse Dec from file. */
Dec pDec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dec_;
  }
}

/* Entrypoint: parse Dec from string. */
Dec psDec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dec_;
  }
}

/* Entrypoint: parse Label from file. */
Label pLabel(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse Label from string. */
Label psLabel(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse Uses from file. */
Uses pUses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uses_;
  }
}

/* Entrypoint: parse Uses from string. */
Uses psUses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uses_;
  }
}

/* Entrypoint: parse Variable from file. */
Variable pVariable(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variable_;
  }
}

/* Entrypoint: parse Variable from string. */
Variable psVariable(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variable_;
  }
}

/* Entrypoint: parse Type from file. */
Type pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type from string. */
Type psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type_specifier from file. */
Type_specifier pType_specifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_specifier_;
  }
}

/* Entrypoint: parse Type_specifier from string. */
Type_specifier psType_specifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_specifier_;
  }
}

/* Entrypoint: parse Constant from file. */
Constant pConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Constant from string. */
Constant psConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Cmdlist from file. */
Cmdlist pCmdlist(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmdlist_;
  }
}

/* Entrypoint: parse Cmdlist from string. */
Cmdlist psCmdlist(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmdlist_;
  }
}

/* Entrypoint: parse Cmd from file. */
Cmd pCmd(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse Cmd from string. */
Cmd psCmd(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse Cmd_type from file. */
Cmd_type pCmd_type(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_type_;
  }
}

/* Entrypoint: parse Cmd_type from string. */
Cmd_type psCmd_type(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_type_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp15(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp15(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from file. */
Exp pExp16(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp from string. */
Exp psExp16(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Procedure from file. */
Procedure pProcedure(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedure_;
  }
}

/* Entrypoint: parse Procedure from string. */
Procedure psProcedure(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedure_;
  }
}

/* Entrypoint: parse Assignment_op from file. */
Assignment_op pAssignment_op(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignment_op_;
  }
}

/* Entrypoint: parse Assignment_op from string. */
Assignment_op psAssignment_op(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = jair__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = jair__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  jair__delete_buffer(buf, scanner);
  jair_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignment_op_;
  }
}



