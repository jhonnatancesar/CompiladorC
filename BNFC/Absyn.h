/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct Prog_;
typedef struct Prog_ *Prog;

struct Id_;
typedef struct Id_ *Id;

struct Ident_type_;
typedef struct Ident_type_ *Ident_type;

struct Dec_;
typedef struct Dec_ *Dec;

struct Label_;
typedef struct Label_ *Label;

struct Uses_;
typedef struct Uses_ *Uses;

struct Variable_;
typedef struct Variable_ *Variable;

struct Type_;
typedef struct Type_ *Type;

struct Type_specifier_;
typedef struct Type_specifier_ *Type_specifier;

struct Constant_;
typedef struct Constant_ *Constant;

struct Cmdlist_;
typedef struct Cmdlist_ *Cmdlist;

struct Cmd_;
typedef struct Cmd_ *Cmd;

struct Cmd_type_;
typedef struct Cmd_type_ *Cmd_type;

struct Exprecion_;
typedef struct Exprecion_ *Exprecion;

struct Exp_;
typedef struct Exp_ *Exp;

struct Procedure_;
typedef struct Procedure_ *Procedure;

/********************   Abstract Syntax Classes    ********************/

struct Prog_
{
  enum { is_Program } kind;
  union
  {
    struct { Dec dec_; Ident ident_; } program_;
  } u;
};

Prog make_Program(Ident p0, Dec p1);

struct Id_
{
  enum { is_Ident } kind;
  union
  {
    struct { Ident_type ident_type_; } ident_;
  } u;
};

Id make_Ident(Ident_type p0);

struct Ident_type_
{
  enum { is_Idletter, is_Iddigt } kind;
  union
  {
  } u;
};

Ident_type make_Idletter(void);
Ident_type make_Iddigt(void);

struct Dec_
{
  enum { is_Block } kind;
  union
  {
    struct { Cmdlist cmdlist_; Constant constant_; Label label_; Type type_; Uses uses_; Variable variable_; } block_;
  } u;
};

Dec make_Block(Label p0, Uses p1, Variable p2, Type p3, Constant p4, Cmdlist p5);

struct Label_
{
  enum { is_Label } kind;
  union
  {
    struct { Ident ident_; } label_;
  } u;
};

Label make_Label(Ident p0);

struct Uses_
{
  enum { is_Uses } kind;
  union
  {
    struct { Ident ident_1, ident_2; } uses_;
  } u;
};

Uses make_Uses(Ident p0, Ident p1);

struct Variable_
{
  enum { is_Variable } kind;
  union
  {
    struct { Ident ident_; Type type_; } variable_;
  } u;
};

Variable make_Variable(Ident p0, Type p1);

struct Type_
{
  enum { is_Type } kind;
  union
  {
    struct { Type_specifier type_specifier_; } type_;
  } u;
};

Type make_Type(Type_specifier p0);

struct Type_specifier_
{
  enum { is_Tint, is_Tfloat, is_Tdouble } kind;
  union
  {
  } u;
};

Type_specifier make_Tint(void);
Type_specifier make_Tfloat(void);
Type_specifier make_Tdouble(void);

struct Constant_
{
  enum { is_Constant } kind;
  union
  {
  } u;
};

Constant make_Constant(void);

struct Cmdlist_
{
  enum { is_Cmdlist } kind;
  union
  {
    struct { Cmd cmd_1, cmd_2; } cmdlist_;
  } u;
};

Cmdlist make_Cmdlist(Cmd p0, Cmd p1);

struct Cmd_
{
  enum { is_Cmd } kind;
  union
  {
    struct { Cmd_type cmd_type_; } cmd_;
  } u;
};

Cmd make_Cmd(Cmd_type p0);

struct Cmd_type_
{
  enum { is_Cmd_goto, is_Cmd_assign, is_Cmd_while, is_Cmd_for, is_Cmd_if, is_Cmd_output } kind;
  union
  {
    struct { Label label_; } cmd_goto_;
    struct { Exprecion exprecion_; Variable variable_; } cmd_assign_;
    struct { Cmdlist cmdlist_; Exprecion exprecion_; } cmd_while_;
    struct { Cmdlist cmdlist_; Exprecion exprecion_; } cmd_for_;
    struct { Cmdlist cmdlist_1, cmdlist_2; Exprecion exprecion_; } cmd_if_;
    struct { Exprecion exprecion_; } cmd_output_;
  } u;
};

Cmd_type make_Cmd_goto(Label p0);
Cmd_type make_Cmd_assign(Variable p0, Exprecion p1);
Cmd_type make_Cmd_while(Exprecion p0, Cmdlist p1);
Cmd_type make_Cmd_for(Exprecion p0, Cmdlist p1);
Cmd_type make_Cmd_if(Exprecion p0, Cmdlist p1, Cmdlist p2);
Cmd_type make_Cmd_output(Exprecion p0);

struct Exprecion_
{
  enum { is_Exprecion } kind;
  union
  {
    struct { Exp exp_; } exprecion_;
  } u;
};

Exprecion make_Exprecion(Exp p0);

struct Exp_
{
  enum { is_Expeq, is_Expenq, is_Expmaior, is_Expmenor, is_Expmaioreq, is_Expmenoreq } kind;
  union
  {
    struct { Exp exp_1, exp_2; } expeq_;
    struct { Exp exp_1, exp_2; } expenq_;
    struct { Exp exp_1, exp_2; } expmaior_;
    struct { Exp exp_1, exp_2; } expmenor_;
    struct { Exp exp_1, exp_2; } expmaioreq_;
    struct { Exp exp_1, exp_2; } expmenoreq_;
  } u;
};

Exp make_Expeq(Exp p0, Exp p1);
Exp make_Expenq(Exp p0, Exp p1);
Exp make_Expmaior(Exp p0, Exp p1);
Exp make_Expmenor(Exp p0, Exp p1);
Exp make_Expmaioreq(Exp p0, Exp p1);
Exp make_Expmenoreq(Exp p0, Exp p1);

struct Procedure_
{
  enum { is_Funtion } kind;
  union
  {
    struct { Cmdlist cmdlist_; Ident ident_; Variable variable_; } funtion_;
  } u;
};

Procedure make_Funtion(Ident p0, Variable p1, Cmdlist p2);

/***************************   Cloning   ******************************/

Prog clone_Prog(Prog p);
Id clone_Id(Id p);
Ident_type clone_Ident_type(Ident_type p);
Dec clone_Dec(Dec p);
Label clone_Label(Label p);
Uses clone_Uses(Uses p);
Variable clone_Variable(Variable p);
Type clone_Type(Type p);
Type_specifier clone_Type_specifier(Type_specifier p);
Constant clone_Constant(Constant p);
Cmdlist clone_Cmdlist(Cmdlist p);
Cmd clone_Cmd(Cmd p);
Cmd_type clone_Cmd_type(Cmd_type p);
Exprecion clone_Exprecion(Exprecion p);
Exp clone_Exp(Exp p);
Procedure clone_Procedure(Procedure p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prog(Prog p);
void free_Id(Id p);
void free_Ident_type(Ident_type p);
void free_Dec(Dec p);
void free_Label(Label p);
void free_Uses(Uses p);
void free_Variable(Variable p);
void free_Type(Type p);
void free_Type_specifier(Type_specifier p);
void free_Constant(Constant p);
void free_Cmdlist(Cmdlist p);
void free_Cmd(Cmd p);
void free_Cmd_type(Cmd_type p);
void free_Exprecion(Exprecion p);
void free_Exp(Exp p);
void free_Procedure(Procedure p);


#endif
